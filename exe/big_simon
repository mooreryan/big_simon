#!/usr/bin/env ruby
Signal.trap("PIPE", "EXIT")

require "parse_fasta"
require "trollop"

require "big_simon"

opts = Trollop.options do
  version BigSimon::VERSION_BANNER

  banner <<-EOS

#{BigSimon::VERSION_BANNER}

  Hi, I'm BigSimon!  I'm here to help you figure out the hosts for your viruses.

  Options:
  EOS

  opt :viruses, "Path to fasta file(s) with viruses", type: :strings
  opt :hosts, "Path to fasta file(s) with hosts", type: :strings
  opt :outdir, "Output directory", default: "big_simon"
  opt :threads, "Number of threads to use", default: 1
end

Rya::AbortIf.logger.debug { "Command line opts: #{opts.inspect}" }

BigSimon::Utils.check_opt! opts, :viruses
BigSimon::Utils.check_opt! opts, :hosts

# Check infiles
[opts[:viruses], opts[:hosts]].flatten.each do |fname|
  BigSimon::Utils.check_file! fname
end

Rya::AbortIf.abort_unless opts[:threads] > 0,
                          "--threads must be > 0"

programs = [
    "WIsH",
    "VirHostMatcher",
]

outdir       = opts[:outdir]
threads      = opts[:threads]
virus_fnames = opts[:viruses]
host_fnames  = opts[:hosts]

tmpdir       = File.join opts[:outdir], "big_simon_tmp"
tmpdir_virus = File.join tmpdir, "virus"
tmpdir_host  = File.join tmpdir, "host"

predictons_dir = File.join outdir, "individual_predictions"

all_predictions_fname = File.join outdir, "all_predictions.txt"

name_map_virus, all_ids_virus = BigSimon::Utils.set_up_tmp_dirs virus_fnames, tmpdir_virus, "virus"
name_map_host, all_ids_host   = BigSimon::Utils.set_up_tmp_dirs host_fnames, tmpdir_host, "host"

wish_outf = BigSimon::Runners.wish BigSimon::WISH, tmpdir_virus, tmpdir_host, predictons_dir, threads
vhm_outf  = BigSimon::Runners.vir_host_matcher BigSimon::VHM, tmpdir_virus, tmpdir_host, predictons_dir

host_info_wish = BigSimon::Parsers.wish wish_outf
host_info_vhm  = BigSimon::Parsers.vir_host_matcher vhm_outf

host_info = BigSimon::Pipeline.collate_host_results [host_info_wish, host_info_vhm], programs

mean_rank       = {}
all_predictions = []
host_info.each do |virus, program_predictions|
  program_predictions.each do |program, predictions|
    predictions.each_with_index do |(host, score), idx|
      rank = idx + 1

      all_predictions << [name_map_virus[virus], name_map_host[host], program, score, rank]
    end
  end
end

all_vs = Set.new
all_hs = Set.new
all_predictions.each do |virus, host, program, score, rank|
  all_vs << virus
  all_hs << host

  unless mean_rank.has_key? virus
    mean_rank[virus] = {}
  end

  unless mean_rank[virus].has_key? host
    mean_rank[virus][host] = []
  end
  mean_rank[virus][host] << rank
end


mean_ranks_fname = File.join outdir, "mean_ranks.txt"
File.open(mean_ranks_fname, "w") do |f|

  # lock the order
  all_vs = all_vs.to_a
  all_hs = all_hs.to_a

  f.puts all_hs.join "\t"

  all_vs.each do |virus|
    f.print virus
    all_hs.each do |host|
      p [:apple, mean_rank[virus][host]]

      f.print "\t#{mean_rank[virus][host].reduce(:+) / mean_rank[virus][host].count.to_f}"
    end

    f.puts
  end

end


# Sort by virus, then by host, then by program.
# TODO change the order of the outputs rather than sorting them after the fact.
all_predictions.sort! do |(vir1, host1, prog1, _, _), (vir2, host2, prog2, _, _)|
  vir_comp = vir1 <=> vir2

  if vir_comp.zero?
    host_comp = host1 <=> host2

    if host_comp.zero?
      prog_comp = prog1 <=> prog2
    else
      host_comp
    end
  else
    vir_comp
  end
end

File.open(all_predictions_fname, "w") do |f|
  f.puts %w[virus host program rank score].join "\t"

  all_predictions.each do |ary|
    f.puts ary.join "\t"
  end
end


FileUtils.rm_r tmpdir